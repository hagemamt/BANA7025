+ valence + tempo,
test = "F")
# next to be added is energy
add1(lm(track_popularity ~ instrumentalness + energy, data = songs),
track_popularity ~ danceability + energy + key + loudness
+ speechiness + acousticness + instrumentalness + liveness
+ valence + tempo,
test = "F")
# loudness is next
add1(lm(track_popularity ~ instrumentalness + energy + loudness,
data = songs),
track_popularity ~ danceability + energy + key + loudness
+ speechiness + acousticness + instrumentalness + liveness
+ valence + tempo,
test = "F")
# valence
add1(lm(track_popularity ~ instrumentalness + energy + loudness + valence,
data = songs),
track_popularity ~ danceability + energy + key + loudness
+ speechiness + acousticness + instrumentalness + liveness
+ valence + tempo,
test = "F")
# liveness
add1(lm(track_popularity ~ instrumentalness + energy + loudness + valence
+ liveness,
data = songs),
track_popularity ~ danceability + energy + key + loudness
+ speechiness + acousticness + instrumentalness + liveness
+ valence + tempo,
test = "F")
# acousticness
add1(lm(track_popularity ~ instrumentalness + energy + loudness + valence
+ liveness + acousticness,
data = songs),
track_popularity ~ danceability + energy + key + loudness
+ speechiness + acousticness + instrumentalness + liveness
+ valence + tempo,
test = "F")
# add danceability
add1(lm(track_popularity ~ instrumentalness + energy + loudness + valence
+ liveness + acousticness,
data = songs),
track_popularity ~ danceability + energy + key + loudness
+ speechiness + acousticness + instrumentalness + liveness
+ valence + tempo,
test = "F")
# add danceability
add1(lm(track_popularity ~ instrumentalness + energy + loudness + valence
+ liveness + acousticness + danceability,
data = songs),
track_popularity ~ danceability + energy + key + loudness
+ speechiness + acousticness + instrumentalness + liveness
+ valence + tempo,
test = "F")
# add tempo
add1(lm(track_popularity ~ instrumentalness + energy + loudness + valence
+ liveness + acousticness + danceability + tempo,
data = songs),
track_popularity ~ danceability + energy + key + loudness
+ speechiness + acousticness + instrumentalness + liveness
+ valence + tempo,
test = "F")
# add speechiness
add1(lm(track_popularity ~ instrumentalness + energy + loudness + valence
+ liveness + acousticness + danceability + tempo + speechiness,
data = songs),
track_popularity ~ danceability + energy + key + loudness
+ speechiness + acousticness + instrumentalness + liveness
+ valence + tempo,
test = "F")
# key is not found to be significant
model <- lm(track_popularity ~ instrumentalness + energy + loudness + valence
+ liveness + acousticness + danceability + tempo + speechiness,
data = songs)
summary(model)
# model adequacy checking
model$residuals
# model adequacy checking
# obtain MSRes
MSRes <- summary(model)$sigma^2
MSRes
# model adequacy checking
qqnorm(model$residuals)
qqline(model$residuals)
# generate residual plot, fitted values vs residual
plot(model$fitted.values, model$residuals, pch = 20)
abline(h = 0, col = "grey")
hist(model$residuals)
model2 <- lm(sqrt_track_popularity ~ instrumentalness + energy + loudness +
valence + liveness + acousticness + danceability + tempo +
speechiness,
data = songs)
# qq plot reveals non-normality, so transform y
songs$sqrt_track_popularity <- sqrt(songs$track_popularity)
model2 <- lm(sqrt_track_popularity ~ instrumentalness + energy + loudness +
valence + liveness + acousticness + danceability + tempo +
speechiness,
data = songs)
summary(model2)
par(mfrow = c(1,2))
qqnorm(model2$residuals)
qqline(model2$residuals)
hist(model2$residuals)
par(mfrow = c(1,1))
# log transformation
songs$log_track_popularity <- log(songs$track_popularity)
model3 <- lm(log_track_popularity ~ instrumentalness + energy + loudness +
valence + liveness + acousticness + danceability + tempo +
speechiness,
data = songs)
# log transformation
songs$log_track_popularity <- log(songs$track_popularity)
model3 <- lm(log_track_popularity ~ instrumentalness + energy + loudness +
valence + liveness + acousticness + danceability + tempo +
speechiness,
data = songs)
max(songs$log_track_popularity)
min(songs$log_track_popularity)
count(songs$log_track_popularity == -Inf)
sum(songs$log_track_popularity == -Inf)
model3 <- lm(log_track_popularity ~ instrumentalness + energy + loudness +
valence + liveness + acousticness + danceability + tempo +
speechiness,
data = songs[ , -which(songs$log_track_popularity > -Inf)])
# log transformation
songs$log_track_popularity <- log(songs$track_popularity)
model3 <- lm(log_track_popularity ~ instrumentalness + energy + loudness +
valence + liveness + acousticness + danceability + tempo +
speechiness,
data = songs[ , -which(songs$log_track_popularity > -Inf)])
model3 <- lm(log_track_popularity ~ instrumentalness + energy + loudness +
valence + liveness + acousticness + danceability + tempo +
speechiness,
data = songs[ , which(songs$log_track_popularity > -Inf)])
# log transformation
songs$log_track_popularity <- log(songs$track_popularity)
model3 <- lm(log_track_popularity ~ instrumentalness + energy + loudness +
valence + liveness + acousticness + danceability + tempo +
speechiness,
data = songs[ , which(songs$log_track_popularity > -Inf)])
model3 <- lm(log_track_popularity ~ instrumentalness + energy + loudness +
valence + liveness + acousticness + danceability + tempo +
speechiness,
data = songs[songs$log_track_popularity > -Inf,])
summary(model3)
par(mfrow = c(1,2))
qqnorm(model3$residuals)
qqline(model3$residuals)
hist(model3$residuals)
par(mfrow = c(1,1))
# reciprocal square root transformation
songs$recip_sqrt_track_popularity <- songs$track_popularity ^ (-.5)
model4 <- lm(recip_sqrt_track_popularity ~ instrumentalness + energy + loudness +
valence + liveness + acousticness + danceability + tempo +
speechiness,
data = songs[songs$log_track_popularity > -Inf,])
summary(model4)
par(mfrow = c(1,2))
qqnorm(model4$residuals)
qqline(model4$residuals)
hist(model4$residuals)
par(mfrow = c(1,1))
# reciprocal transformation
songs$recip_track_popularity <- songs$track_popularity ^ (-1)
model5 <- lm(recip_track_popularity ~ instrumentalness + energy + loudness +
valence + liveness + acousticness + danceability + tempo +
speechiness,
data = songs[songs$log_track_popularity > -Inf,])
summary(model5)
par(mfrow = c(1,2))
qqnorm(model5$residuals)
qqline(model5$residuals)
hist(model5$residuals)
par(mfrow = c(1,1))
?arcsin()
# arcsin transformation
songs$arcsin_track_popularity <- arcsin(songs$sqrt_track_popularity)
# arcsin transformation
songs$arcsin_track_popularity <- asin(songs$sqrt_track_popularity)
model6 <- lm(asin_track_popularity ~ instrumentalness + energy + loudness +
valence + liveness + acousticness + danceability + tempo +
speechiness,
data = songs[!(is.nan(songs$asin_track_popularity)),])
# arcsin transformation
songs$asin_track_popularity <- asin(songs$sqrt_track_popularity)
model6 <- lm(asin_track_popularity ~ instrumentalness + energy + loudness +
valence + liveness + acousticness + danceability + tempo +
speechiness,
data = songs[!(is.nan(songs$asin_track_popularity)),])
summary(model6)
par(mfrow = c(1,2))
qqnorm(model6$residuals)
qqline(model6$residuals)
hist(model6$residuals)
# build the first model
model1 <- lm(track_popularity ~ instrumentalness + energy + loudness + valence
+ liveness + acousticness + danceability + tempo + speechiness,
data = songs)
summary(model1)
# model adequacy checking
par(mfrow = c(1,2))
qqnorm(model1$residuals)
qqline(model1$residuals)
hist(model1$residuals)
par(mfrow = c(1,1))
qqnorm(model1$residuals, main = "Q-Q Plot of Model 1 Residuals")
qqline(model1$residuals)
par(mfrow = c(1,1))
# model adequacy checking
par(mfrow = c(1,2))
qqnorm(model1$residuals, main = "Q-Q Plot of Model 1 Residuals")
qqline(model1$residuals)
hist(model1$residuals)
par(mfrow = c(1,1))
# model adequacy checking
par(mfrow = c(1,2))
qqnorm(model1$residuals, main = "Q-Q Plot of Model 1 Residuals")
qqline(model1$residuals)
hist(model1$residuals, main = "Histogram of Model 1 Residuals")
library(tidyverse)
library(scales)
library(table1)
library(htmltools)
library(cowplot)
library(rlang)
library(Hmisc)
library(gridExtra)
library(ggcorrplot)
songs <- read.csv('spotify_songs.csv', stringsAsFactors = FALSE)
getwd()
setwd('C:/Users/Mark/Source/BANA 7025 - Data Wrangling/final project')
songs <- read.csv('spotify_songs.csv', stringsAsFactors = FALSE)
str(songs)
songs$track_album_release_date <- as.Date(songs$track_album_release_date)
songs$playlist_genre <- as.factor(songs$playlist_genre)
songs$playlist_subgenre <- as.factor(songs$playlist_subgenre)
nrow(songs[complete.cases(songs), ])
colSums(is.na(songs))
na_rows <- nrow(songs) - nrow(songs[complete.cases(songs), ])
pct_na_rows <- na_rows / nrow(songs)
songs <- na.omit(songs)
summary(songs)
songs %>%
summarise_if(is.numeric, mean)
unused_cols <- c('track_id', 'track_album_id', 'track_album_name',
'playlist_name', 'playlist_id', 'playlist_subgenre')
songs <- songs[ , -which(names(songs) %in% c(unused_cols))]
dim(songs)
head(songs)
# What is the makeup of songs in our data set, in terms of genre?
# What are the characteristics of each genre?
table1::table1(~ track_popularity + danceability + energy + key + loudness +
mode + speechiness + acousticness + instrumentalness +
liveness + valence | playlist_genre, data = songs)
songs %>% ggplot(aes(x = playlist_genre, fill = playlist_genre)) +
geom_bar() +
ggtitle("Number of Songs Within Each Genre") +
scale_fill_discrete(name = "Genre") +
scale_x_discrete(name = NULL) +
scale_y_continuous(expand = c(0, 0), name = "Count of \n Songs") +
theme(axis.title.y = element_text(angle = 0, vjust = .5)) +
theme(panel.grid.major.x = element_blank()) +
coord_cartesian(ylim = c(0, 7000))
popularity_means <- songs %>%
group_by(playlist_genre) %>%
dplyr::summarize(mean_popularity = mean(track_popularity))
popularity_means %>% ggplot(aes(x = playlist_genre, y = mean_popularity, fill = playlist_genre)) +
geom_bar(stat = "identity") +
ggtitle("Average Popularity of Each Genre") +
scale_fill_discrete(name = "Genre") +
scale_x_discrete(name = NULL) +
scale_y_continuous(expand = c(0,0), name = "Average \n Popularity") +
theme(axis.title.y = element_text(angle = 0, vjust = .5)) +
theme(panel.grid.major.x = element_blank()) +
coord_cartesian(ylim = c(0, 55))
# Which artists with at least five tracks in the data set are more or less popular?
songs %>%
group_by(track_artist) %>%
filter(n() >= 5) %>%
dplyr::summarize(mean_popularity = mean(track_popularity)) %>%
arrange(desc(mean_popularity)) %>%
slice_head(n = 10)
songs %>%
group_by(track_artist) %>%
filter(n() >= 5) %>%
summarize(mean_popularity = mean(track_popularity)) %>%
arrange(mean_popularity)  %>%
slice_head(n = 10)
songs %>%
group_by(track_artist) %>%
filter(n() >= 5) %>%
dplyr::summarize(mean_popularity = mean(track_popularity)) %>%
arrange(mean_popularity)  %>%
slice_head(n = 10)
# How many cross-genre artists are there?
songs %>%
group_by(track_artist) %>%
dplyr::summarize(n_unique = n_distinct(playlist_genre)) %>%
filter(n_unique >= 2) %>%
count()
# Which artists have tracks in the greatest variety of genres?
songs %>%
group_by(track_artist) %>%
dplyr::summarize(n_unique = n_distinct(playlist_genre)) %>%
filter(n_unique >= 2) %>%
arrange(desc(n_unique)) %>%
slice_head(n = 10)
# What dates are covered in the data set?
min(songs$track_album_release_date)
max(songs$track_album_release_date)
myplots <-
map(names(songs %>% select(where(is.numeric)) %>% select(-mode)),
function(colName) {
songs %>%
ggplot(aes(x = playlist_genre,
y = !! sym(colName),
fill = playlist_genre)) +
geom_boxplot() +
theme(legend.position = "NONE") +
labs(title = capitalize(colName), x = "", y = "")
})
gridExtra::grid.arrange(grobs = myplots[c(1:4)])
gridExtra::grid.arrange(grobs = myplots[c(5:8)])
gridExtra::grid.arrange(grobs = myplots[c(9:12)])
corr_songs <-cor(songs %>% select(where(is.numeric)) %>% select(-mode))
ggcorrplot(corr_songs, method = "circle", type ="lower")
# forward stepwise regression
add1(lm(track_popularity ~ 1, data = songs),
track_popularity ~ danceability + energy + key + loudness
+ speechiness + acousticness + instrumentalness + liveness
+ valence + tempo,
test = "F")
# instrumentalness has the highest significant F value, so add it first
add1(lm(track_popularity ~ instrumentalness, data = songs),
track_popularity ~ danceability + energy + key + loudness
+ speechiness + acousticness + instrumentalness + liveness
+ valence + tempo,
test = "F")
# add energy
add1(lm(track_popularity ~ instrumentalness + energy, data = songs),
track_popularity ~ danceability + energy + key + loudness
+ speechiness + acousticness + instrumentalness + liveness
+ valence + tempo,
test = "F")
# add loudness
add1(lm(track_popularity ~ instrumentalness + energy + loudness,
data = songs),
track_popularity ~ danceability + energy + key + loudness
+ speechiness + acousticness + instrumentalness + liveness
+ valence + tempo,
test = "F")
# add valence
add1(lm(track_popularity ~ instrumentalness + energy + loudness + valence,
data = songs),
track_popularity ~ danceability + energy + key + loudness
+ speechiness + acousticness + instrumentalness + liveness
+ valence + tempo,
test = "F")
# add liveness
add1(lm(track_popularity ~ instrumentalness + energy + loudness + valence
+ liveness,
data = songs),
track_popularity ~ danceability + energy + key + loudness
+ speechiness + acousticness + instrumentalness + liveness
+ valence + tempo,
test = "F")
# add acousticness
add1(lm(track_popularity ~ instrumentalness + energy + loudness + valence
+ liveness + acousticness,
data = songs),
track_popularity ~ danceability + energy + key + loudness
+ speechiness + acousticness + instrumentalness + liveness
+ valence + tempo,
test = "F")
# add danceability
add1(lm(track_popularity ~ instrumentalness + energy + loudness + valence
+ liveness + acousticness + danceability,
data = songs),
track_popularity ~ danceability + energy + key + loudness
+ speechiness + acousticness + instrumentalness + liveness
+ valence + tempo,
test = "F")
# add tempo
add1(lm(track_popularity ~ instrumentalness + energy + loudness + valence
+ liveness + acousticness + danceability + tempo,
data = songs),
track_popularity ~ danceability + energy + key + loudness
+ speechiness + acousticness + instrumentalness + liveness
+ valence + tempo,
test = "F")
# add speechiness
add1(lm(track_popularity ~ instrumentalness + energy + loudness + valence
+ liveness + acousticness + danceability + tempo + speechiness,
data = songs),
track_popularity ~ danceability + energy + key + loudness
+ speechiness + acousticness + instrumentalness + liveness
+ valence + tempo,
test = "F")
# build the first model
model1 <- lm(track_popularity ~ instrumentalness + energy + loudness + valence
+ liveness + acousticness + danceability + tempo + speechiness,
data = songs)
summary(model1)
# model adequacy checking
par(mfrow = c(1,2))
qqnorm(model1$residuals, main = "Q-Q Plot of Model 1 Residuals")
qqline(model1$residuals)
hist(model1$residuals, main = "Histogram of Model 1 Residuals")
par(mfrow = c(1,1))
# square root transformation
songs$sqrt_track_popularity <- sqrt(songs$track_popularity)
model2 <- lm(sqrt_track_popularity ~ instrumentalness + energy + loudness +
valence + liveness + acousticness + danceability + tempo +
speechiness,
data = songs)
# log transformation
songs$log_track_popularity <- log(songs$track_popularity)
model3 <- lm(log_track_popularity ~ instrumentalness + energy + loudness +
valence + liveness + acousticness + danceability + tempo +
speechiness,
data = songs[songs$log_track_popularity > -Inf,])
# reciprocal square root transformation
songs$recip_sqrt_track_popularity <- songs$track_popularity ^ (-.5)
model4 <- lm(recip_sqrt_track_popularity ~ instrumentalness + energy + loudness +
valence + liveness + acousticness + danceability + tempo +
speechiness,
data = songs[songs$log_track_popularity > -Inf,])
# reciprocal transformation
songs$recip_track_popularity <- songs$track_popularity ^ (-1)
model5 <- lm(recip_track_popularity ~ instrumentalness + energy + loudness +
valence + liveness + acousticness + danceability + tempo +
speechiness,
data = songs)
# arcsin transformation
songs$asin_track_popularity <- asin(songs$sqrt_track_popularity)
model5 <- lm(recip_track_popularity ~ instrumentalness + energy + loudness +
valence + liveness + acousticness + danceability + tempo +
speechiness,
data = songs[!(is.nan(songs$recip_sqrt_track_popularity)),])
max(songs$recip_track_popularity)
min(songs$recip_track_popularity)
model5 <- lm(recip_track_popularity ~ instrumentalness + energy + loudness +
valence + liveness + acousticness + danceability + tempo +
speechiness,
data = songs[songs$recip_sqrt_track_popularity < Inf,])
# arcsin transformation
songs$asin_track_popularity <- asin(songs$sqrt_track_popularity)
model6 <- lm(asin_track_popularity ~ instrumentalness + energy + loudness +
valence + liveness + acousticness + danceability + tempo +
speechiness,
data = songs[!(is.nan(songs$asin_track_popularity)),])
par(mfrow = c(2, 3))
qqnorm(model2$residuals, main = "Model 2")
qqline(model2$residuals)
qqnorm(model3$residuals, main = "Q-Q Plot of Model 3 Residuals")
qqline(model3$residuals)
qqnorm(model4$residuals, main = "Q-Q Plot of Model 4 Residuals")
qqline(model4$residuals)
qqnorm(model5$residuals, main = "Model 5")
qqline(model5$residuals)
qqnorm(model6$residuals, main = "Model 6")
qqline(model6$residuals)
par(mfrow = c(1,1))
par(mfrow = c(2, 3))
qqnorm(model2$residuals, main = "Square root transformation")
qqline(model2$residuals)
qqnorm(model3$residuals, main = "Log transformation")
qqline(model3$residuals)
qqnorm(model4$residuals, main = "Reciprocal square root transformation")
par(mfrow = c(1,1))
par(mfrow = c(2, 3))
qqnorm(model2$residuals, main = "Square root")
qqline(model2$residuals)
qqnorm(model3$residuals, main = "Log")
qqline(model3$residuals)
qqnorm(model4$residuals, main = "Reciprocal square root")
qqline(model4$residuals)
qqnorm(model5$residuals, main = "Reciprocal")
qqline(model5$residuals)
qqnorm(model6$residuals, main = "Arcsin")
qqline(model6$residuals)
par(mfrow = c(1,1))
summary(model2)
summary(model2)$adj.r.squared
cbind(c('Model 1', 'Model 2', 'Model 3', 'Model 4', 'Model 5', 'Model 6'),
c(summary(model1)$adj.r.squared,
summary(model2)$adj.r.squared,
summary(model3)$adj.r.squared,
summary(model4)$adj.r.squared,
summary(model5)$adj.r.squared,
summary(model6)$adj.r.squared))
cbind(c(1:6),
c(summary(model1)$adj.r.squared,
summary(model2)$adj.r.squared,
summary(model3)$adj.r.squared,
summary(model4)$adj.r.squared,
summary(model5)$adj.r.squared,
summary(model6)$adj.r.squared))
df <- data.frame(Model = c(1:6),
Transformation = c("None",
"Square root",
"Log",
"Reciprocal square root",
"Reciprocal",
"Arcsin"),
AdjRsqr = c(summary(model1)$adj.r.squared,
summary(model2)$adj.r.squared,
summary(model3)$adj.r.squared,
summary(model4)$adj.r.squared,
summary(model5)$adj.r.squared,
summary(model6)$adj.r.squared))
df
